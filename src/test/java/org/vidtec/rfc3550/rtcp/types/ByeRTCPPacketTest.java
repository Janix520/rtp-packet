package org.vidtec.rfc3550.rtcp.types;

import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;
import static org.testng.Assert.fail;

import java.net.UnknownHostException;

import org.testng.annotations.Test;
import org.vidtec.rfc3550.rtcp.types.RTCPPacket.PayloadType;

@Test
public class ByeRTCPPacketTest 
{

	
	public void testCanCastSelfToConcreteType()
	{
		final ByeRTCPPacket r = ByeRTCPPacket.builder()
				.withSsrcs(20)
				.build();
		
		final ByeRTCPPacket p = r.asConcreteType();
		assertEquals(p.packetLength(), 8, "incorrect packet length");

	}

	public void testCanCreateEmptyByePacketFromBuilder()
	{
		final byte[] data = { (byte)0x80, (byte)0xCB, 0x00, 0x04 };

		ByeRTCPPacket r = ByeRTCPPacket.builder()
				.build();
		
		assertEquals(r.packetLength(), 4, "incorrect packet length");
		assertTrue(r.is(PayloadType.BYE), "incorrect payload type");
		assertTrue(!r.is(PayloadType.SDES), "incorrect payload type");
		assertTrue(!r.is(null), "incorrect payload type");
		assertEquals(r.payloadType(), PayloadType.BYE, "incorrect payload type");

		assertTrue(r.reason() != null, "incorrect reason");
		assertTrue(r.reason().isEmpty(), "incorrect reason");

		assertTrue(r.ssrcs() != null, "incorrect ssrcs");
		assertTrue(!r.hasSsrcs(), "incorrect ssrcs");
		assertEquals(r.ssrcs(), new long[] {  }, "incorrect ssrcs");
		assertEquals(r.ssrcCount(), 0, "incorrect ssrcs");
		
		assertEquals(r.asByteArray(), data, "packet data not reformed correctly.");
		
		r = ByeRTCPPacket.builder()
				.withReason(null)
				.build();
		
		assertEquals(r.packetLength(), 4, "incorrect packet length");
		assertTrue(r.is(PayloadType.BYE), "incorrect payload type");
		assertTrue(!r.is(PayloadType.SDES), "incorrect payload type");
		assertTrue(!r.is(null), "incorrect payload type");
		assertEquals(r.payloadType(), PayloadType.BYE, "incorrect payload type");

		assertTrue(r.reason() != null, "incorrect reason");
		assertTrue(r.reason().isEmpty(), "incorrect reason");

		assertTrue(r.ssrcs() != null, "incorrect ssrcs");
		assertTrue(!r.hasSsrcs(), "incorrect ssrcs");
		assertEquals(r.ssrcs(), new long[] {  }, "incorrect ssrcs");
		assertEquals(r.ssrcCount(), 0, "incorrect ssrcs");
		
		assertEquals(r.asByteArray(), data, "packet data not reformed correctly.");
	}
	
	
	public void testCanCreateSimpleByePacketFromBuilder()
	{
		final byte[] data = { (byte)0x81, (byte)0xCB, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x14, 0x01, 0x30, 0x00, 0x00 };

		final ByeRTCPPacket r = ByeRTCPPacket.builder()
				.withSsrcs(20)
				.withReason("0")
				.build();
		
		assertEquals(r.packetLength(), 12, "incorrect packet length");
		assertTrue(r.is(PayloadType.BYE), "incorrect payload type");
		assertTrue(!r.is(PayloadType.SDES), "incorrect payload type");
		assertTrue(!r.is(null), "incorrect payload type");
		assertEquals(r.payloadType(), PayloadType.BYE, "incorrect payload type");

		assertTrue(r.reason() != null, "incorrect reason");
		assertTrue(!r.reason().isEmpty(), "incorrect reason");
		assertEquals(r.reason(), "0", "incorrect reason");

		assertTrue(r.ssrcs() != null, "incorrect ssrcs");
		assertTrue(r.hasSsrcs(), "incorrect ssrcs");
		assertEquals(r.ssrcs(), new long[] { 20 }, "incorrect ssrcs");
		assertEquals(r.ssrcCount(), 1, "incorrect ssrcs");
		
		assertEquals(r.asByteArray(), data, "packet data not reformed correctly.");
	}

	
	public void testCanValidatesCorrectlyFromBuilder() throws UnknownHostException
	{
		// more than 31 ssrcs
		
		try
		{
			ByeRTCPPacket.builder()
					.withSsrcs(20)
					.withReason("01234567890123456789012345678901234567890123456789" +
								"01234567890123456789012345678901234567890123456789" +
								"01234567890123456789012345678901234567890123456789" +
								"01234567890123456789012345678901234567890123456789" +
								"01234567890123456789012345678901234567890123456789" +
								"0123456789")
					.build();
			
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "'reason' message is too long, max is 255 bytes, but saw - 260", "wrong validation message");
		}
	}
	

	public void testCanCreateEmptyByePacketFromBuilderAtLimits()
	{
		final byte[] data = { (byte)0x9F, (byte)0xCB, 0x01, (byte)0x80, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14,
				(byte)0xFF, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 
		};

		final ByeRTCPPacket r = ByeRTCPPacket.builder()
				.withSsrcs(20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
						   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20)
				.withReason("00000000000000000000000000000000000000000000000000" +
							"00000000000000000000000000000000000000000000000000" +
							"00000000000000000000000000000000000000000000000000" +
							"00000000000000000000000000000000000000000000000000" +
							"00000000000000000000000000000000000000000000000000" +
							"00000")
				.build();
		

		assertEquals(r.packetLength(), 4 + (31 * 4) + 256, "incorrect packet length");
		assertTrue(r.is(PayloadType.BYE), "incorrect payload type");
		assertTrue(!r.is(PayloadType.SDES), "incorrect payload type");
		assertTrue(!r.is(null), "incorrect payload type");
		assertEquals(r.payloadType(), PayloadType.BYE, "incorrect payload type");

		assertTrue(r.reason() != null, "incorrect reason");
		assertTrue(!r.reason().isEmpty(), "incorrect reason");
		assertEquals(r.reason(), "00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000", "incorrect reason");

		assertTrue(r.ssrcs() != null, "incorrect ssrcs");
		assertTrue(r.hasSsrcs(), "incorrect ssrcs");
		assertEquals(r.ssrcs(), new long[] { 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
											 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 }, "incorrect ssrcs");
		assertEquals(r.ssrcCount(), 31, "incorrect ssrcs");
		
		assertEquals(r.asByteArray(), data, "packet data not reformed correctly.");
	}
		
	

	
	
	public void testCanCreateSimpleByePacketFromByteArray()
	{
//		final byte[] data = { (byte)0x82, (byte)0xC9, 0x00, (byte)0x38, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x14, 
//								    0x04, 0x03, 0x02, 0x01, 0x01, 0x03, 0x02, 0x01, 0x05, 0x04, 0x03, 0x02, 0x06, 0x03, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
//								    0x04, 0x03, 0x02, 0x01, 0x01, 0x03, 0x02, 0x01, 0x05, 0x04, 0x03, 0x02, 0x06, 0x03, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00
//		};
//
//		final ByeRTCPPacket r = ByeRTCPPacket.fromByteArray(data);
//		
//		assertEquals(r.packetLength(), 56, "incorrect packet length");
//		assertTrue(r.is(PayloadType.RR), "incorrect payload type");
//		assertTrue(!r.is(PayloadType.SDES), "incorrect payload type");
//		assertTrue(!r.is(null), "incorrect payload type");
//		assertEquals(r.payloadType(), PayloadType.RR, "incorrect payload type");
//
//		assertTrue(r.blocks() != null, "incorrect blocks data");
//		assertTrue(!r.blocks().isEmpty(), "incorrect blocks data");
//		assertEquals(r.blocks().size(), 2, "incorrect blocks size");
//
//		assertEquals(r.ssrcSenderIdentifier(), 20, "incorrect ssrc sender");
//		
//		assertEquals(r.asByteArray(), data, "packet data not reformed correctly.");
	}

	
	
	
// FIXME !!!!!!!	
	public void testCanCreateSimpleByePacketFromByteArrayAtLimits()
	{
		final byte[] data = { (byte)0x9F, (byte)0xCB, 0x01, (byte)0x80, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 
				0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x14,
				(byte)0xFF, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
				0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 
		};

		final ByeRTCPPacket r = ByeRTCPPacket.fromByteArray(data);

		assertEquals(r.packetLength(), 4 + (31 * 4) + 256, "incorrect packet length");
		assertTrue(r.is(PayloadType.BYE), "incorrect payload type");
		assertTrue(!r.is(PayloadType.SDES), "incorrect payload type");
		assertTrue(!r.is(null), "incorrect payload type");
		assertEquals(r.payloadType(), PayloadType.BYE, "incorrect payload type");

		assertTrue(r.reason() != null, "incorrect reason");
		assertTrue(!r.reason().isEmpty(), "incorrect reason");
		assertEquals(r.reason(), "00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000000000000000000000000000000000000000000000000" +
								"00000", "incorrect reason");

		assertTrue(r.ssrcs() != null, "incorrect ssrcs");
		assertTrue(r.hasSsrcs(), "incorrect ssrcs");
		assertEquals(r.ssrcs(), new long[] { 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
											 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 }, "incorrect ssrcs");
		assertEquals(r.ssrcCount(), 31, "incorrect ssrcs");
		
		assertEquals(r.asByteArray(), data, "packet data not reformed correctly.");
	}
	
	
	public void testCanValidatesCorrectlyFromByteArray() throws UnknownHostException
	{
		try
		{
			ByeRTCPPacket.fromByteArray( null );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "packet data cannot be null", "wrong validation message");
		}
		try
		{
			ByeRTCPPacket.fromByteArray(new byte[] { (byte)0x80 } );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "Packet too short, expecting at least 4 bytes, but found 1", "wrong validation message");
		}
		try
		{
			ByeRTCPPacket.fromByteArray(new byte[] { (byte)0x82, (byte)0xC9, 0x00, 0x08, 
																0x00, 0x00, 0x00, 0x00 } );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "Packet states 2 ssrcs, so expecting length 12, but only found 8 bytes.", "wrong validation message");
		}
		try
		{
			ByeRTCPPacket.fromByteArray(new byte[] { (byte)0x80, (byte)0xD9, 0x00, 0x00, 
																0x00, 0x00, 0x00, 0x00 } );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "Invalid or unexpected packet type - should be 203", "wrong validation message");
		}
		try
		{
			ByeRTCPPacket.fromByteArray(new byte[] { (byte)0x80, (byte)0xC9, 0x00, 0x10, 
																0x00, 0x00, 0x00, 0x00 } );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "Packet states 16 bytes length, but actual length is 8", "wrong validation message");
		}
		try
		{
			ByeRTCPPacket.fromByteArray(new byte[] { (byte)0xA0, (byte)0xC9, 0x00, 0x08, 
																0x00, 0x00, 0x00, 0x00 } );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "BYE packet should never be padded, malformed packet found", "wrong validation message");
		}
		try
		{
			ByeRTCPPacket.fromByteArray(new byte[] { (byte)0x81, (byte)0xC9, 0x00, 0x09, 
																0x00, 0x00, 0x00, 0x00,
																0x01 } );
			fail("Expected error");
		}
		catch(IllegalArgumentException e)
		{
			assertEquals(e.getMessage(), "Expected at least 1 bytes, but found 0", "wrong validation message");
		}

	} 
	

	

}
